set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
set_property(GLOBAL PROPERTY USE_FOLDERS On)

set(RUPKG_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
set(RUPKG_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
set(RUPKG_LIST_DIR ${CMAKE_CURRENT_LIST_DIR})
set(RUPKG_THIRD_PARTY_SOURCE_DIR ${RUPKG_SOURCE_DIR}/third_party)
set(RUPKG_THIRD_PARTY_BINARY_DIR ${RUPKG_BINARY_DIR}/third_party)

if (DEFINED RUPKG_UTIL_ROOT AND EXISTS "${RUPKG_UTIL_ROOT}")
    include(${RUPKG_UTIL_ROOT}/RuXPackageUtilsTargets.cmake)
endif()

list(REMOVE_DUPLICATES CMAKE_MODULE_PATH)

include(BinaryToCode) 
include(CheckTypeSize)
include(CheckFunctionExists)
include(CheckIncludeFile)
include(CheckCSourceCompiles)
include(CheckIncludeFiles)
include(CMakeParseArguments)
include(RupkgInitialize)

if (RUPKG_COMPILER_MSVC)
    if (RUPKG_ARCHITECTURE_X64 OR RUPKG_ARCHITECTURE_X86)
        enable_language(ASM_MASM)
    endif()
else()
    if (NOT RUPKG_PLATFORM_EMSCRIPTEN)
        enable_language(ASM)
    endif()

    if (RUPKG_PLATFORM_IOS OR RUPKG_PLATFORM_MACOS)
        enable_language(OBJC OBJCXX)
    endif()
endif()

set(CMAKE_XCODE_ATTRIBUTE_OTHER_CODE_SIGN_FLAGS "-o linker-signed")

set_property(GLOBAL PROPERTY AUTOGEN_SOURCE_GROUP gen)

function(rupkg_install_dependencies target)
    cmake_parse_arguments("args" "" "PROFILE;DESTINATION" "" ${ARGN})
    get_dynamic_libraries(INPUT ${target} OUTPUT dylibs)
    get_target_property(ignore_target_filters ${target} IGNORE_INSTALL_DEPENDENCIES_FILTERS)
    get_target_property(target_type ${target} TYPE)
    foreach(dylib ${dylibs})
        set(should_install on)
        if (ignore_target_filters)
            foreach(filter ${ignore_target_filters})
                cmake_language(EVAL CODE "${filter}(${dylib} ${dylib}_result)")
                if (${dylib}_result)
                    set(should_install off)
                    break()
                endif()
            endforeach()
        endif()
        if (should_install)
            if ("${args_PROFILE}" STREQUAL "tool")
                get_target_property(target_is_bundle ${target} MACOSX_BUNDLE)
                get_target_property(target_is_appimage ${target} APPIMAGE)
                if (target_is_bundle)
                    rupkg_install(CODE "get_filename_component(tmp \"$<TARGET_BUNDLE_DIR:${target}>\" NAME)")
                    rupkg_install(PKG_TARGET ${dylib} PROFILE "tool" DESTINATION "${args_DESTINATION}/\${tmp}/Contents/Frameworks")
                elseif (target_is_appimage)
                    rupkg_install(PKG_TARGET ${dylib} PROFILE "tool" DESTINATION "${args_DESTINATION}/$<TARGET_FILE_NAME:${target}>.AppDir/usr/lib")
                else()
                    rupkg_install(PKG_TARGET ${dylib} PROFILE "tool" DESTINATION "${args_DESTINATION}")
                endif()
            elseif ("${args_PROFILE}" STREQUAL "test")
                get_target_property(target_is_bundle ${target} MACOSX_BUNDLE)
                get_target_property(target_is_appimage ${target} APPIMAGE)
                if (target_is_bundle)
                    rupkg_install(CODE "get_filename_component(tmp \"$<TARGET_BUNDLE_DIR:${target}>\" NAME)")
                    rupkg_install(PKG_TARGET ${dylib} PROFILE "test" DESTINATION "${args_DESTINATION}/\${tmp}/Contents/Frameworks")
                elseif (target_is_appimage)
                    rupkg_install(PKG_TARGET ${dylib} PROFILE "test" DESTINATION "${args_DESTINATION}/$<TARGET_FILE_NAME:${target}>.AppDir/usr/lib")
                else()
                    rupkg_install(PKG_TARGET ${dylib} PROFILE "test" DESTINATION "${args_DESTINATION}")
                endif()
            elseif ("${args_PROFILE}" STREQUAL "runtime")
                rupkg_install(PKG_TARGET ${dylib} PROFILE "runtime" DESTINATION "${args_DESTINATION}")
            endif()
        endif()
    endforeach()
    if ("${target_type}" STREQUAL "STATIC_LIBRARY" AND "${args_PROFILE}" STREQUAL "runtime")

    endif()
endfunction()

function(__rupkg_install_binary)
    cmake_parse_arguments("args" "" "PKG_TARGET;DESTINATION" "CONFIG" ${ARGV})
    if (NOT DEFINED args_CONFIG)
        set(args_CONFIG "Debug;Release")
    endif()
    get_target_property(target_type ${args_PKG_TARGET} TYPE)
    get_target_property(target_is_imported ${args_PKG_TARGET} IMPORTED)
    set(dest_suffix )
    set(dest_usr_suffix )
    if (RUPKG_PLATFORM_LINUX AND ("${target_type}" STREQUAL "EXECUTABLE" OR "${target_type}" STREQUAL "MODULE_LIBRARY"))
        get_target_property(is_appimage ${args_PKG_TARGET} APPIMAGE)
        if (is_appimage)
            set(dest_root_suffix "$<TARGET_FILE_NAME:${args_PKG_TARGET}>.AppDir")
            set(dest_usr_suffix "${dest_root_suffix}/usr")
            set(dest_suffix "${dest_usr_suffix}/bin")
        endif()
    endif()
    if (target_is_imported)
        _install(IMPORTED_RUNTIME_ARTIFACTS ${args_PKG_TARGET}
            CONFIGURATIONS ${args_CONFIG}
            LIBRARY
            DESTINATION "bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_suffix}"
            RUNTIME
            DESTINATION "bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_suffix}"
            BUNDLE
            DESTINATION "bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_suffix}")
    else()
        _install(TARGETS ${args_PKG_TARGET}
            ${export_args}
            CONFIGURATIONS ${args_CONFIG}
            LIBRARY
            DESTINATION "bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_suffix}"
            RUNTIME
            DESTINATION "bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_suffix}"
            BUNDLE
            DESTINATION "bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_suffix}"
            ${args_FILE_SET_ARGS})
    endif()
    if ("${target_type}" STREQUAL "EXECUTABLE" OR "${target_type}" STREQUAL "MODULE_LIBRARY")
        if (RUPKG_PLATFORM_MACOS)
            get_target_property(is_bundle ${args_PKG_TARGET} MACOSX_BUNDLE)
            if (is_bundle)
                set_target_properties(${args_PKG_TARGET} PROPERTIES INSTALL_RPATH @loader_path/../Frameworks)
            else()
                set_target_properties(${args_PKG_TARGET} PROPERTIES INSTALL_RPATH @loader_path)
            endif()
        elseif (RUPKG_PLATFORM_LINUX)
            get_target_property(is_appimage ${args_PKG_TARGET} APPIMAGE)
            if (is_appimage)
                set_target_properties(${args_PKG_TARGET} PROPERTIES INSTALL_RPATH $ORIGIN/../lib)
                _install(FILES $<TARGET_PROPERTY:${args_PKG_TARGET},APPIMAGE_ICON>
                    DESTINATION "bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_root_suffix}"
                    RENAME "icon.png"
                    CONFIGURATIONS ${args_CONFIG})
                _install(CODE "
                    if($<LOWER_CASE:\"${args_CONFIG}\"> MATCHES \"$<LOWER_CASE:$<CONFIG>>\")
                        file(CREATE_LINK
                            \"usr/bin/$<TARGET_FILE_NAME:${args_PKG_TARGET}>\"
                            \"\${CMAKE_INSTALL_PREFIX}/bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_root_suffix}/AppRun\"
                            SYMBOLIC)
                        file(WRITE \"\${CMAKE_INSTALL_PREFIX}/bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_root_suffix}/$<TARGET_FILE_BASE_NAME:${args_PKG_TARGET}>.desktop\"
                            \"[Desktop Entry]\nType=Application\nName=$<TARGET_FILE_BASE_NAME:${args_PKG_TARGET}>\nIcon=icon\nCategories=$<TARGET_PROPERTY:${args_PKG_TARGET},APPIMAGE_CATEGORIES>;\")
                    endif()
                ")
                rupkg_end_project_hook("
                    _install(CODE [[
                        if($<LOWER_CASE:\"${args_CONFIG}\"> MATCHES \"$<LOWER_CASE:$<CONFIG>>\")
                            execute_process(COMMAND \"${RUPKG_BINARY_DIR}/appimagetool-x86_64.AppImage\" \"--appimage-extract-and-run\"
                                \"\${CMAKE_INSTALL_PREFIX}/bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_root_suffix}\"
                                \"\${CMAKE_INSTALL_PREFIX}/bin/${RUPKG_TRIPLE}/${args_DESTINATION}/$<TARGET_FILE_NAME:${args_PKG_TARGET}>.AppImage\")
                            file(REMOVE_RECURSE \"\${CMAKE_INSTALL_PREFIX}/bin/${RUPKG_TRIPLE}/${args_DESTINATION}/${dest_root_suffix}\")
                        endif()
                    ]])
                ")
            else()
                set_target_properties(${args_PKG_TARGET} PROPERTIES INSTALL_RPATH $ORIGIN)
            endif()
        elseif (RUPKG_PLATFORM_EMSCRIPTEN)
            _install(FILES $<TARGET_FILE_DIR:${args_PKG_TARGET}>/$<TARGET_FILE_PREFIX:${args_PKG_TARGET}>$<TARGET_FILE_BASE_NAME:${args_PKG_TARGET}>.wasm
                DESTINATION "bin/${RUPKG_TRIPLE}/${args_DESTINATION}"
                CONFIGURATIONS ${args_CONFIG})
        endif()
    endif()
endfunction()

function(rupkg_install mode)
    if ("${mode}" STREQUAL "PKG_TARGET")
        cmake_parse_arguments("args" "EXPORT" "PROFILE;PKG_TARGET;DESTINATION;FILE_SET_ARGS" "EXPORT_PACKAGE" ${ARGV})
        if (NOT DEFINED args_EXPORT_PACKAGE)
            set(args_EXPORT_PACKAGE ${PROJECT_NAME})
        endif()
        if (NOT DEFINED args_PKG_TARGET)
            message(FATAL_ERROR "TARGET is not defined")
            return()
        endif()
        string(REPLACE " " ";" args_FILE_SET_ARGS "${args_FILE_SET_ARGS}")
        get_target_property(target_is_imported ${args_PKG_TARGET} IMPORTED)
        get_target_property(aliased_target ${args_PKG_TARGET} ALIASED_TARGET)
        if (aliased_target)
            set(args_PKG_TARGET ${aliased_target})
        endif()
        set(export_args)
        if ("${args_PROFILE}" STREQUAL "runtime")
            if (args_EXPORT)
                set(export_args EXPORT ${args_EXPORT_PACKAGE}Targets)
                set_property(GLOBAL APPEND PROPERTY _RUPKG_${args_EXPORT_PACKAGE}_EXPORT_RUNTIME ${args_PKG_TARGET})
            endif()
            set_property(GLOBAL APPEND PROPERTY _RUPKG_${args_EXPORT_PACKAGE}_INSTALL_RUNTIME ${args_PKG_TARGET})
            if (target_is_imported)
                _install(IMPORTED_RUNTIME_ARTIFACTS ${args_PKG_TARGET}
                    RUNTIME
                    DESTINATION "lib/${RUPKG_TRIPLE}/$<LOWER_CASE:$<CONFIG>>/${args_DESTINATION}"
                    LIBRARY
                    DESTINATION "lib/${RUPKG_TRIPLE}/$<LOWER_CASE:$<CONFIG>>/${args_DESTINATION}")
                if (RUPKG_PLATFORM_WIN32 OR RUPKG_PLATFORM_UWP)
                    _install(FILES $<TARGET_LINKER_FILE:${args_PKG_TARGET}>
                        DESTINATION "lib/${RUPKG_TRIPLE}/$<LOWER_CASE:$<CONFIG>>/${args_DESTINATION}")
                else()
                    _install(IMPORTED_RUNTIME_ARTIFACTS ${args_PKG_TARGET}
                        LIBRARY
                        DESTINATION "lib/${RUPKG_TRIPLE}/$<LOWER_CASE:$<CONFIG>>/${args_DESTINATION}")
                endif()
            else()
                _install(TARGETS ${args_PKG_TARGET}
                    ${export_args}
                    RUNTIME
                    DESTINATION "lib/${RUPKG_TRIPLE}/$<LOWER_CASE:$<CONFIG>>/${args_DESTINATION}"
                    ARCHIVE
                    DESTINATION "lib/${RUPKG_TRIPLE}/$<LOWER_CASE:$<CONFIG>>/${args_DESTINATION}"
                    LIBRARY
                    DESTINATION "lib/${RUPKG_TRIPLE}/$<LOWER_CASE:$<CONFIG>>/${args_DESTINATION}"
                    ${args_FILE_SET_ARGS})
            endif()
        elseif ("${args_PROFILE}" STREQUAL "test")
            set_property(GLOBAL APPEND PROPERTY _RUPKG_${args_EXPORT_PACKAGE}_INSTALL_TEST ${args_PKG_TARGET})
            __rupkg_install_binary(PKG_TARGET ${args_PKG_TARGET} DESTINATION "$<LOWER_CASE:$<CONFIG>>/${args_DESTINATION}")
        elseif ("${args_PROFILE}" STREQUAL "tool")
            if (args_EXPORT)
                set(export_args EXPORT ${args_EXPORT_PACKAGE}ToolsTargets)
                set_property(GLOBAL APPEND PROPERTY _RUPKG_${args_EXPORT_PACKAGE}_EXPORT_TOOL ${args_PKG_TARGET})
            endif()
            set_property(GLOBAL APPEND PROPERTY _RUPKG_${args_EXPORT_PACKAGE}_INSTALL_TOOL ${args_PKG_TARGET})
            
            __rupkg_install_binary(PKG_TARGET ${args_PKG_TARGET} DESTINATION ${args_DESTINATION} CONFIG Release)
        else()
            if (target_is_imported)
                _install(IMPORTED_RUNTIME_ARTIFACTS ${args_PKG_TARGET}
                    BUNDLE
                    DESTINATION "${args_DESTINATION}"
                    RUNTIME
                    DESTINATION "${args_DESTINATION}"
                    LIBRARY
                    DESTINATION "${args_DESTINATION}")
                if (RUPKG_PLATFORM_WIN32 OR RUPKG_PLATFORM_UWP)
                    _install(FILES $<TARGET_LINKER_FILE:${args_PKG_TARGET}>
                        DESTINATION "${args_DESTINATION}")
                endif()
            else()
                _install(TARGETS ${args_PKG_TARGET}
                    EXPORT ${args_EXPORT}
                    RUNTIME
                    DESTINATION "${args_DESTINATION}"
                    ARCHIVE
                    DESTINATION "${args_DESTINATION}"
                    LIBRARY
                    DESTINATION "${args_DESTINATION}"
                    BUNDLE
                    DESTINATION "${args_DESTINATION}"
                    ${args_FILE_SET_ARGS})
            endif()
        endif()
    else()
        _install(${ARGV})
    endif()
endfunction()
 
function(rupkg_add_default_definitions target)
    if (RUPKG_PLATFORM_WIN32 OR RUPKG_PLATFORM_UWP)
        target_compile_definitions(${target} PRIVATE NOMINMAX _UNICODE UNICODE _CRT_SECURE_NO_WARNINGS _SCL_SECURE_NO_WARNINGS)
    endif()
endfunction()

function(unpack_link_libraries_genex ex output)
    set(lib "${ex}")
    while(on)
        if ("${lib}" MATCHES "^\\$<BUILD_INTERFACE:(.*)>$")
            set(lib ${CMAKE_MATCH_1})
        elseif ("${lib}" MATCHES "^\\$<INSTALL_INTERFACE:(.*)>$")
            set(lib ${CMAKE_MATCH_1})
        else()
            set(${output} ${lib} PARENT_SCOPE)
            break()
        endif()
    endwhile()
endfunction()

function(get_interface_dependencies target)
    cmake_parse_arguments("args" "RAW" "OUTPUT_PUBLIC_VAR;OUTPUT_PRIVATE_VAR" "" ${ARGN})

    get_target_property(library_interface_dependencies ${target} INTERFACE_LINK_LIBRARIES)
    set(temp )
    if (library_interface_dependencies)
        list(APPEND temp ${library_interface_dependencies})
    endif()
    set(result_public )
    set(result_private )
    foreach(d ${temp})
        if ("${d}" MATCHES "^\\$<LINK_ONLY:(.*)>$")
            if (NOT args_RAW)
                unpack_link_libraries_genex("${CMAKE_MATCH_1}" tmp)
                list(APPEND result_private ${tmp})
            else()
                list(APPEND result_private ${CMAKE_MATCH_1})
            endif()
        else()
            if (NOT args_RAW)
                unpack_link_libraries_genex("${d}" tmp)
                list(APPEND result_public ${tmp})
            else()
                list(APPEND result_public ${d})
            endif()
        endif()
    endforeach()
    list(REMOVE_DUPLICATES result_public)
    list(REMOVE_DUPLICATES result_private)
    set(${args_OUTPUT_PUBLIC_VAR} ${result_public} PARENT_SCOPE)
    set(${args_OUTPUT_PRIVATE_VAR} ${result_private} PARENT_SCOPE)
endfunction()

function(get_dynamic_libraries)
    cmake_parse_arguments("args" "" "OUTPUT" "INPUT" ${ARGN})
    set(processed_targets )
    set(not_found_targets )

    set(result )

    while(args_INPUT)
        list(GET args_INPUT 0 library)
        list(REMOVE_AT args_INPUT 0) 
        if (library IN_LIST processed_targets OR
            library IN_LIST not_found_targets)
            continue()
        endif()

        list(APPEND processed_targets ${library})

        get_target_property(library_dependencies ${library} LINK_LIBRARIES)
        get_interface_dependencies(${library} RAW
            OUTPUT_PUBLIC_VAR library_interface_dependencies_public
            OUTPUT_PRIVATE_VAR library_interface_dependencies_private)
        set(found_libraries)
        if (library_interface_dependencies_public)
            list(APPEND found_libraries ${library_interface_dependencies_public})
        endif()
        if (library_interface_dependencies_private)
            list(APPEND found_libraries ${library_interface_dependencies_private})
        endif()
        if (library_dependencies)
            list(APPEND found_libraries ${library_dependencies})
        endif()
        set(dependencies)
        foreach(library ${found_libraries})
            unpack_link_libraries_genex("${library}" tmp)
            list(APPEND dependencies ${tmp})
        endforeach()

        foreach(dependency ${dependencies})
            if (TARGET ${dependency})
                get_target_property(dependency_type ${dependency} TYPE)
                get_target_property(is_framework ${dependency} FRAMEWORK)
                list(APPEND args_INPUT ${dependency})
                if ("${dependency_type}" STREQUAL "SHARED_LIBRARY" AND NOT is_framework)
                    list(APPEND result ${dependency})
                endif()
            endif()
        endforeach()
    endwhile()
    list(REMOVE_DUPLICATES result)
    set(${args_OUTPUT} ${result} PARENT_SCOPE)
endfunction()

function(get_static_libraries)
    cmake_parse_arguments("args" "" "OUTPUT" "INPUT" ${ARGN})
    
    set(processed_targets )
    set(not_found_targets )

    set(result )

    while(args_INPUT)
        list(GET args_INPUT 0 library)
        list(REMOVE_AT args_INPUT 0) 
        if (library IN_LIST processed_targets OR
            library IN_LIST not_found_targets)
            continue()
        endif()

        list(APPEND processed_targets ${library})

        get_target_property(library_dependencies ${library} LINK_LIBRARIES)
        get_interface_dependencies(${library} RAW
            OUTPUT_PUBLIC_VAR library_interface_dependencies_public
            OUTPUT_PRIVATE_VAR library_interface_dependencies_private)
        set(found_libraries)
        if (library_interface_dependencies_public)
            list(APPEND found_libraries ${library_interface_dependencies_public})
        endif()
        if (library_interface_dependencies_private)
            list(APPEND found_libraries ${library_interface_dependencies_private})
        endif()
        if (library_dependencies)
            list(APPEND found_libraries ${library_dependencies})
        endif()
        set(dependencies)
        foreach(library ${found_libraries})
            unpack_link_libraries_genex("${library}" tmp)
            list(APPEND dependencies ${tmp})
        endforeach()

        foreach(dependency ${dependencies})
            if (TARGET ${dependency})
                get_target_property(dependency_type ${dependency} TYPE)
                get_target_property(is_framework ${dependency} FRAMEWORK)
                list(APPEND args_INPUT ${dependency})
                if (NOT is_framework)
                    if ("${dependency_type}" STREQUAL "STATIC_LIBRARY")
                        list(APPEND args_INPUT ${dependency})
                        list(APPEND result ${dependency})
                    elseif ("${dependency_type}" STREQUAL "INTERFACE_LIBRARY")
                        list(APPEND args_INPUT ${dependency})
                    endif()
                endif()
            endif()
        endforeach()
    endwhile()
    list(REMOVE_DUPLICATES result)
    set(${args_OUTPUT} ${result} PARENT_SCOPE)
endfunction()

macro(rupkg_start_project)
    cmake_parse_arguments("args" "" "PROJECT_NAME" "" "${ARGN}")

    project(${args_PROJECT_NAME})
endmacro()

macro(rupkg_end_project)
    get_property(tools GLOBAL PROPERTY "_RUPKG_${PROJECT_NAME}_INSTALL_TOOL")
    get_property(tests GLOBAL PROPERTY "_RUPKG_${PROJECT_NAME}_INSTALL_TEST")
    get_property(runtimes GLOBAL PROPERTY "_RUPKG_${PROJECT_NAME}_INSTALL_RUNTIME")
    get_property(export_tools GLOBAL PROPERTY "_RUPKG_${PROJECT_NAME}_EXPORT_TOOL")
    get_property(export_runtimes GLOBAL PROPERTY "_RUPKG_${PROJECT_NAME}_EXPORT_RUNTIME")
    get_property(utils GLOBAL PROPERTY "_RUPKG_${PROJECT_NAME}_UTIL")
    get_property(end_script GLOBAL PROPERTY __RUPKG_ON_END_PROJECT_${PROJECT_NAME})

    message(STATUS "Finish generate project ${PROJECT_NAME}")

    foreach(runtime ${runtimes})
        rupkg_install_dependencies(${runtime} PROFILE runtime)
    endforeach()

    foreach(tool ${tools})
        rupkg_install_dependencies(${tool} PROFILE tool)
    endforeach()

    foreach(test ${tests})
        rupkg_install_dependencies(${test} PROFILE test)
    endforeach()
    
    if (export_runtimes)
        file(READ ${RUPKG_LIST_DIR}/ConfigTemplate_triple.cmake.in ConfigTripleCmakeIn)
        string(CONFIGURE "${ConfigTripleCmakeIn}" ConfigTripleCmakeIn @ONLY)
        file(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config_${RUPKG_TRIPLE}.cmake CONTENT "${ConfigTripleCmakeIn}")
        rupkg_install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config_${RUPKG_TRIPLE}.cmake DESTINATION lib/cmake/${PROJECT_NAME}/${RUPKG_TRIPLE} RENAME ${PROJECT_NAME}Config.cmake)

        file(READ ${RUPKG_LIST_DIR}/ConfigTemplate.cmake.in ConfigCmakeIn)
        string(CONFIGURE "${ConfigCmakeIn}" ConfigCmakeIn @ONLY)
        file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "${ConfigCmakeIn}")
        rupkg_install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake DESTINATION lib/cmake/${PROJECT_NAME})
        rupkg_install(EXPORT ${PROJECT_NAME}Targets DESTINATION lib/cmake/${PROJECT_NAME}/${RUPKG_TRIPLE} NAMESPACE ${PROJECT_NAME}::)
    endif()

    if (export_tools)
        file(READ ${RUPKG_LIST_DIR}/ToolsConfigTemplate_triple.cmake.in ToolsConfigTripleCmakeIn)
        string(CONFIGURE "${ToolsConfigTripleCmakeIn}" ToolsConfigTripleCmakeIn @ONLY)
        file(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ToolsConfig_${RUPKG_TRIPLE}.cmake CONTENT "${ToolsConfigTripleCmakeIn}")
        rupkg_install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ToolsConfig_${RUPKG_TRIPLE}.cmake DESTINATION lib/cmake/${PROJECT_NAME}Tools/${RUPKG_TRIPLE} RENAME ${PROJECT_NAME}Config.cmake)

        file(READ ${RUPKG_LIST_DIR}/ToolsConfigTemplate.cmake.in ToolsConfigCmakeIn)
        string(CONFIGURE "${ToolsConfigCmakeIn}" ToolsConfigCmakeIn @ONLY)
        file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ToolsConfig.cmake "${ToolsConfigCmakeIn}")
        rupkg_install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ToolsConfig.cmake DESTINATION lib/cmake/${PROJECT_NAME}Tools)
        rupkg_install(EXPORT ${PROJECT_NAME}ToolsTargets DESTINATION lib/cmake/${PROJECT_NAME}Tools/${RUPKG_TRIPLE} NAMESPACE ${PROJECT_NAME}::)
    endif()

    if (utils)
        list(REMOVE_DUPLICATES utils)

        set(export_utils )
        foreach(util ${utils})
            get_target_property(target_type ${util} TYPE)
            if (NOT ${target_type} STREQUAL "UTILITY")
                list(APPEND export_utils ${util})
            endif()
        endforeach()
        _export(TARGETS ${export_utils} FILE ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}UtilsTargets.cmake NAMESPACE ${PROJECT_NAME}::)
    endif()

    cmake_language(EVAL CODE "${end_script}")
endmacro()

function(rupkg_end_project_hook code)
    set_property(GLOBAL APPEND_STRING PROPERTY __RUPKG_ON_END_PROJECT_${PROJECT_NAME} "${code}\n")
endfunction()

function(__rupkg_set_folder target class_output)
    set(class "${PROJECT_NAME}")
    set(argn ${ARGN})
    set(no_folder off)
    if ("NO_FOLDER" IN_LIST argn)
        list(REMOVE_ITEM argn NO_FOLDER)
        set(no_folder on)
    endif()
    if (argn)
        list(GET argn 0 class)
    endif()
    if (NOT no_folder)
        set_target_properties(${target} PROPERTIES FOLDER "${PROJECT_NAME}")
    endif()
    set(${class_output} ${class} PARENT_SCOPE)
endfunction()

function(rupkg_mark_as_runtime target)
    __rupkg_set_folder(${target} class ${ARGN})
    set_property(GLOBAL APPEND PROPERTY _RUPKG_${class}_RUNTIME ${target})
endfunction()

function(rupkg_mark_as_util target)
    if (NOT CMAKE_CROSSCOMPILING)
        __rupkg_set_folder(${target} class ${ARGN})
        set_property(GLOBAL APPEND PROPERTY _RUPKG_${class}_UTIL ${target})
        add_executable(${class}::${target} ALIAS ${target})
    endif()
endfunction()

function(rupkg_mark_as_test target)
    __rupkg_set_folder(${target} class ${ARGN})
    set_property(GLOBAL APPEND PROPERTY _RUPKG_${class}_TEST ${target})
endfunction()

function(rupkg_mark_as_tool target)
    __rupkg_set_folder(${target} class ${ARGN})
    set_property(GLOBAL APPEND PROPERTY _RUPKG_${class}_TOOL ${target})
    set_target_properties(${target} PROPERTIES EXCLUDE_FROM_ALL OFF)
endfunction()

function(rupkg_make_appimage target)
    if (RUPKG_PLATFORM_LINUX)
    	cmake_parse_arguments("args" "" "ICON" "CATEGORIES" ${ARGN})
    	if (NOT DEFINED args_CATEGORIES)
    	    set(args_CATEGORIES "X-None")
    	endif()
    	if (NOT DEFINED args_ICON)
    	    set(args_ICON "${RUPKG_LIST_DIR}/icon-linux.png")
    	endif()
        set_target_properties(${target} PROPERTIES
            APPIMAGE on
            APPIMAGE_ICON "${args_ICON}"
            APPIMAGE_CATEGORIES "${args_CATEGORIES}")
        set(appimagetool_path "${RUPKG_BINARY_DIR}/AppImageTool.AppImage")
        if (NOT EXISTS "${appimagetool_path}")
            set(appimagetool_pkg "${RUPKG_LIST_DIR}/appimagetool-x86_64.tar.xz")
            file(ARCHIVE_EXTRACT
                INPUT "${appimagetool_pkg}"
                DESTINATION "${RUPKG_BINARY_DIR}")
        endif()
    endif()
endfunction()

function(rupkg_merge_static_libraries target)
    cmake_parse_arguments("args" "" "" "TARGETS" ${ARGN})
    set(library_queue ${args_TARGETS})
    foreach(lib ${library_queue})
        string(MD5 library_hash "${lib}")
        set(__Lib_${library_hash}_Is_Public on)
    endforeach()

    set(library_public ${library_queue})
    set(library_private )
    set(library_rest_public )
    set(library_rest_private )

    while(on)
        if ("${library_queue}" STREQUAL "")
            break()
        endif()

        list(GET library_queue 0 current_library)
        list(REMOVE_AT library_queue 0)

        string(MD5 current_library_hash "${current_library}")

        get_interface_dependencies(${current_library} RAW
            OUTPUT_PUBLIC_VAR library_dependencies_public
            OUTPUT_PRIVATE_VAR library_dependencies_private)

        foreach(dep ${library_dependencies_public})
            if (__Lib_${current_library_hash}_Is_Public)
                string(MD5 dep_hash "${dep}")
                set(__Lib_${dep_hash}_Is_Public on)
            endif()
            if ("${dep}" IN_LIST library_public)
                continue()
            endif()
            if (TARGET ${dep})
                get_target_property(dep_type ${dep} TYPE)
                if ("${dep_type}" STREQUAL "STATIC_LIBRARY")
                    list(APPEND library_queue "${dep}")
                    if (__Lib_${current_library_hash}_Is_Public)
                        list(APPEND library_public "${dep}")
                    else()
                        list(APPEND library_private "${dep}")
                    endif()
                elseif ("${dep_type}" STREQUAL "INTERFACE_LIBRARY")
                    list(APPEND library_queue "${dep}")
                    if (__Lib_${current_library_hash}_Is_Public)
                        list(APPEND library_public "${dep}")
                    else()
                        list(APPEND library_private "${dep}")
                    endif()
                else()
                    list(APPEND library_queue "${dep}")
                    if (__Lib_${current_library_hash}_Is_Public)
                        list(APPEND library_rest_public "${dep}")
                    else()
                        list(APPEND library_rest_private "${dep}")
                    endif()
                endif()
            else()
                if (__Lib_${current_library_hash}_Is_Public)
                    list(APPEND library_rest_public "${dep}")
                else()
                    list(APPEND library_rest_private "${dep}")
                endif()
            endif()
        endforeach()

        get_target_property(current_library_type ${current_library} TYPE)
        if ("${current_library_type}" STREQUAL "STATIC_LIBRARY" OR "${current_library_type}" STREQUAL "INTERFACE_LIBRARY")
            foreach(dep ${library_dependencies_private})
                if ("${dep}" IN_LIST library_private)
                    continue()
                endif()
                if (TARGET ${dep})
                    get_target_property(dep_type ${dep} TYPE)
                    if ("${dep_type}" STREQUAL "STATIC_LIBRARY")
                        list(APPEND library_queue "${dep}")
                        list(APPEND library_private "${dep}")
                    elseif ("${dep_type}" STREQUAL "INTERFACE_LIBRARY")
                        list(APPEND library_queue "${dep}")
                        list(APPEND library_private "${dep}")
                    else()
                        list(APPEND library_queue "${dep}")
                        list(APPEND library_rest_private "${dep}")
                    endif()
                else()
                    list(APPEND library_rest_private "${dep}")
                endif()
            endforeach()
        endif()
    endwhile()

    list(REMOVE_DUPLICATES library_public)
    list(REMOVE_DUPLICATES library_private)
    list(REMOVE_DUPLICATES library_rest_public)
    list(REMOVE_DUPLICATES library_rest_private)

    if (off)
        message("library_public ${library_public}")
        message("library_private ${library_private}")
        message("library_rest_public ${library_rest_public}")
        message("library_rest_private ${library_rest_private}")
    endif()

    set(libraries ${library_public} ${library_private})
    set(static_libs )
    foreach(lib ${libraries})
        get_target_property(lib_type ${lib} TYPE)
        if ("${lib_type}" STREQUAL "STATIC_LIBRARY")
            list(APPEND static_libs "${lib}")
        endif()
    endforeach()

    list(REMOVE_DUPLICATES static_libs)

    list(REMOVE_ITEM static_libs ${target})
    
    set(dummyfile ${CMAKE_CURRENT_BINARY_DIR}/${target}.dummy.c)
    cmake_write_source("${dummyfile}" "const char * ${target}_Include_Libs = \"${libraries}\";")

    if (MSVC)
        set(lib_targets)
        foreach(lib ${static_libs})
            list(APPEND lib_targets $<TARGET_FILE:${lib}>)
        endforeach()

        add_custom_command(OUTPUT ${dummyfile}
            COMMAND "${CMAKE_COMMAND}" -E touch ${dummyfile}
            DEPENDS ${static_libs})

        add_library(${target} STATIC ${dummyfile} ${timestamp})
        add_custom_command(TARGET ${target} POST_BUILD
            COMMAND lib /nologo /out:$<TARGET_FILE:${target}> ${lib_targets})
    else()
        set(object_files)
        foreach(lib ${static_libs})
            list(APPEND object_files $<TARGET_OBJECTS:${lib}>)
        endforeach()
        add_library(${target} STATIC ${dummyfile} ${object_files})
    endif()
    set_target_properties(${target} PROPERTIES CONTAINED_TARGETS "${libraries}")
    add_dependencies(${target} ${args_TARGETS})

    set(interface_compile_definitions )
    set(interface_compile_options )
    set(interface_compile_features )
    set(interface_include_directories )
    set(interface_link_options )
    set(interface_link_directories )
    set(interface_sources )
    set(interface_system_include_directories)

    macro(__get_property_and_set lib property output)
        set(tmp)
        get_target_property(tmp ${lib} ${property})
        if (tmp)
            list(APPEND ${output} ${tmp})
        endif()
        unset(tmp)
    endmacro()

    foreach(lib ${library_public})
        __get_property_and_set(${lib} INTERFACE_COMPILE_DEFINITIONS interface_compile_definitions)
        __get_property_and_set(${lib} INTERFACE_COMPILE_OPTIONS interface_compile_options)
        __get_property_and_set(${lib} INTERFACE_COMPILE_FEATURES interface_compile_features)
        __get_property_and_set(${lib} INTERFACE_INCLUDE_DIRECTORIES interface_include_directories)
        __get_property_and_set(${lib} INTERFACE_LINK_OPTIONS interface_link_options)
        __get_property_and_set(${lib} INTERFACE_LINK_DIRECTORIES interface_link_directories)
        __get_property_and_set(${lib} INTERFACE_SOURCES interface_sources)
        __get_property_and_set(${lib} INTERFACE_SYSTEM_INCLUDE_DIRECTORIES interface_system_include_directories)
        get_target_property(__header_sets ${lib} INTERFACE_HEADER_SETS)
        if (__header_sets)
            foreach(__header_set ${__header_sets})
                get_target_property(__header_set_files ${lib} HEADER_SET_${__header_set})
                get_target_property(__header_set_dirs ${lib} HEADER_DIRS_${__header_set})
                target_sources(${target} PUBLIC
                    FILE_SET ${__header_set}
                    TYPE HEADERS
                    BASE_DIRS ${__header_set_dirs}
                    FILES ${__header_set_files})
            endforeach()
        endif()
    endforeach()

    macro(__get_property_and_set_private lib property target_property)
        set(tmp)
        get_target_property(tmp ${lib} ${property})
        if (tmp)
            set_property(TARGET ${target} APPEND PROPERTY ${target_property} ${tmp})
        endif()
        unset(tmp)
    endmacro()

    foreach(lib ${library_private})
        __get_property_and_set_private(${lib} INTERFACE_INCLUDE_DIRECTORIES CONTAIN_PRIVATE_LIBRARIES_INCLUDE_DIRECTORIES)
        __get_property_and_set_private(${lib} INTERFACE_SYSTEM_INCLUDE_DIRECTORIES CONTAIN_PRIVATE_LIBRARIES_SYSTEM_INCLUDE_DIRECTORIES)
        __get_property_and_set_private(${lib} INTERFACE_COMPILE_DEFINITIONS CONTAIN_PRIVATE_LIBRARIES_COMPILE_DEFINITIONS)
        __get_property_and_set_private(${lib} INTERFACE_COMPILE_OPTIONS CONTAIN_PRIVATE_LIBRARIES_COMPILE_OPTIONS)
        __get_property_and_set_private(${lib} INTERFACE_COMPILE_FEATURES CONTAIN_PRIVATE_LIBRARIES_COMPILE_FEATURES)

        __get_property_and_set(${lib} INTERFACE_LINK_OPTIONS interface_link_options)
        __get_property_and_set(${lib} INTERFACE_LINK_DIRECTORIES interface_link_directories)
    endforeach()

    list(REMOVE_DUPLICATES interface_compile_definitions)
    list(REMOVE_DUPLICATES interface_compile_options)
    list(REMOVE_DUPLICATES interface_compile_features)
    list(REMOVE_DUPLICATES interface_include_directories)
    list(REMOVE_DUPLICATES interface_link_options)
    list(REMOVE_DUPLICATES interface_link_directories)
    list(REMOVE_DUPLICATES interface_sources)
    list(REMOVE_DUPLICATES interface_system_include_directories)

    foreach(library ${library_rest_public} ${library_rest_private})
        if ("${library}" MATCHES "(.*)::" AND NOT TARGET "${library}")
            find_package("${CMAKE_MATCH_1}")
        endif()
    endforeach()

    if (off)
        macro(__print_property property)
            set(tmp)
            get_target_property(tmp ${target} ${property})
            if (tmp)
                message("${property} ${tmp}")
            endif()
            unset(tmp)
        endmacro()
        __print_property(CONTAIN_PRIVATE_LIBRARIES_INCLUDE_DIRECTORIES)
        __print_property(CONTAIN_PRIVATE_LIBRARIES_SYSTEM_INCLUDE_DIRECTORIES)
        __print_property(CONTAIN_PRIVATE_LIBRARIES_COMPILE_DEFINITIONS)
        __print_property(CONTAIN_PRIVATE_LIBRARIES_COMPILE_OPTIONS)
        __print_property(CONTAIN_PRIVATE_LIBRARIES_COMPILE_FEATURES)
        message("interface_compile_definitions ${interface_compile_definitions}")
        message("interface_compile_options ${interface_compile_options}")
        message("interface_compile_options ${interface_compile_features}")
        message("interface_include_directories ${interface_include_directories}")
        message("interface_link_options ${interface_link_options}")
        message("interface_link_directories ${interface_link_directories}")
        message("interface_sources ${interface_sources}")
        message("interface_system_include_directories ${interface_system_include_directories}")
    endif()

    target_compile_definitions(${target} INTERFACE ${interface_compile_definitions})
    target_compile_options(${target} INTERFACE ${interface_compile_options})
    target_compile_features(${target} INTERFACE ${interface_compile_features})
    target_include_directories(${target} INTERFACE ${interface_include_directories})
    target_link_options(${target} INTERFACE ${interface_link_options})
    target_link_directories(${target} INTERFACE ${interface_link_directories})
    target_sources(${target} INTERFACE ${interface_sources})
    target_include_directories(${target} SYSTEM INTERFACE ${interface_system_include_directories})
    target_link_libraries(${target} PUBLIC ${library_rest_public} PRIVATE ${library_rest_private})
endfunction()

macro(rupkg_list_sources dir output)
    if (EXISTS ${dir}/Visibility.cmake)
        include(${dir}/Visibility.cmake)
    else()
        set(CMAKE_DIR_ENABLED on)
    endif()
    if (CMAKE_DIR_ENABLED)
        file(GLOB srcs CONFIGURE_DEPENDS ${dir}/*)
        foreach(src ${srcs})
            if (IS_DIRECTORY "${src}")
                rupkg_list_sources(${src} ${output})
            else()
                get_filename_component(filename ${src} NAME)
                if (NOT "${filename}" MATCHES ".cmake$")
                    list(APPEND ${output} ${src})
                endif()
            endif()
        endforeach()
    endif()
    unset(CMAKE_DIR_ENABLED)
endmacro()

function(cmake_write_source path content)
    if (EXISTS ${path})
        file(READ ${path} old_content)
    else()
        set(old_content "")
    endif()

    if (NOT "${old_content}" STREQUAL "${content}")
        file(WRITE "${path}" "${content}")
    endif()
endfunction()

function(rupkg_internal_require)
    foreach(package ${ARGN})
        if (NOT EXISTS "${RUPKG_SOURCE_DIR}/third_party/${package}")
            message(FATAL_ERROR "Package ${package} is not exists")
            return()
        endif()
    endforeach()
    foreach(package ${ARGN})
        get_property(load_package GLOBAL PROPERTY RUPKG_LOAD_PACKAGES)
        if (NOT "${package}" IN_LIST load_package)
            set_property(GLOBAL APPEND PROPERTY RUPKG_LOAD_PACKAGES ${package})

            get_property(export_targets GLOBAL PROPERTY rupkg_package_${package}_TARGETS)
            get_property(export_utils GLOBAL PROPERTY rupkg_package_${package}_UTILS)
            get_property(export_required_package GLOBAL PROPERTY rupkg_package_${package}_PACKAGE)
            get_property(support_platforms GLOBAL PROPERTY rupkg_package_${package}_SUPPORT_PLATFORMS)
            get_property(not_support_platforms GLOBAL PROPERTY rupkg_package_${package}_NOT_SUPPORT_PLATFORMS)

            if (NOT "${RUPKG_PLATFORM}" IN_LIST support_platforms)
                message("Package ${package} is not support ${RUPKG_PLATFORM}")
            endif()

            if (not_support_platforms AND "${RUPKG_PLATFORM}" IN_LIST not_support_platforms)
                message("Package ${package} is not support ${RUPKG_PLATFORM}")
            endif()

            if (export_required_package)
                rupkg_internal_require(${export_required_package})
            endif()

            message(STATUS "Loading package: ${package}")
            add_subdirectory(${RUPKG_SOURCE_DIR}/third_party/${package} ${RUPKG_BINARY_DIR}/third_party/${package} EXCLUDE_FROM_ALL)
            message(STATUS "Loading package: ${package} - Success")

            set(export_all_targets ${export_targets} ${export_utils} ${export_tools} ${export_gui_tools} ${export_ignore})
            list(LENGTH export_all_targets target_count)

            function(__rupkg_get_folder output package target target_count)
                set(folder_prefix "Packages/")
                if (target_count GREATER 1)
                    get_target_property(old_folder ${target} FOLDER)
                    if (old_folder)
                        set(folder ${folder_prefix}${package}/${old_folder})
                    else()
                        set(folder ${folder_prefix}${package})
                    endif()
                else()
                    set(folder "${folder_prefix}")
                endif()
                set(${output} ${folder} PARENT_SCOPE)
            endfunction()

            if (export_targets)
                foreach(lib ${export_targets})
                    if (TARGET ${lib})
                        get_target_property(lib_type ${lib} TYPE)
                        get_target_property(is_imported ${lib} IMPORTED)

                        if (NOT "${lib_type}" STREQUAL "INTERFACE_LIBRARY" AND NOT is_imported)
                            get_target_property(aliased_target ${lib} ALIASED_TARGET)
                            __rupkg_get_folder(folder ${package} ${lib} ${target_count})
                            if (aliased_target)
                                set_target_properties(${aliased_target} PROPERTIES FOLDER "${folder}")
                            else()
                                set_target_properties(${lib} PROPERTIES FOLDER "${folder}")
                            endif()
                        endif()
                    endif()
                endforeach()
            endif()
            
            if (NOT CMAKE_CROSSCOMPILING)
                if (export_utils)
                    foreach(util ${export_utils})
                        if (TARGET ${util})
                            __rupkg_get_folder(folder ${package} ${util} ${target_count})
                            rupkg_mark_as_util(${util} RuXPackage)
                            set_target_properties(${util} PROPERTIES 
                                FOLDER "${folder}")
                        endif()
                    endforeach()
                endif()
            endif()
        endif()
    endforeach()
endfunction()

function(rupkg_subpackage dir)
    if (EXISTS "${CMAKE_CURRENT_LIST_DIR}/${dir}/RupkgInfo.cmake")
        set(__export_targets ${RUPKG_EXPORT_TARGETS})
        set(__export_utils ${RUPKG_EXPORT_UTILS})
        set(__required_packages ${RUPKG_REQUIRED_PACKAGES})
        unset(RUPKG_EXPORT_TARGETS)
        unset(RUPKG_EXPORT_UTILS)
        unset(RUPKG_REQUIRED_PACKAGES)
        include("${CMAKE_CURRENT_LIST_DIR}/${dir}/RupkgInfo.cmake")
        list(APPEND RUPKG_EXPORT_TARGETS ${__export_targets})
        list(APPEND RUPKG_EXPORT_UTILS ${__export_utils})
        list(APPEND RUPKG_REQUIRED_PACKAGES ${__required_packages})

        set(RUPKG_EXPORT_TARGETS ${RUPKG_EXPORT_TARGETS} PARENT_SCOPE)
        set(RUPKG_EXPORT_UTILS ${RUPKG_EXPORT_UTILS} PARENT_SCOPE)
        set(RUPKG_REQUIRED_PACKAGES ${RUPKG_REQUIRED_PACKAGES} PARENT_SCOPE)
    endif()
endfunction()

function(rupkg_load_package package package_dir)
    unset(RUPKG_EXPORT_TARGETS)
    unset(RUPKG_EXPORT_UTILS)
    unset(RUPKG_REQUIRED_PACKAGES)
    unset(RUPKG_SUPPORT_PLATFORMS)
    unset(RUPKG_NOT_SUPPORT_PLATFORMS)

    include("${package_dir}/RupkgInfo.cmake")

    set_property(GLOBAL PROPERTY rupkg_package_${package}_TARGETS ${RUPKG_EXPORT_TARGETS})
    if (NOT CMAKE_CROSSCOMPILING)
        set_property(GLOBAL PROPERTY rupkg_package_${package}_UTILS ${RUPKG_EXPORT_UTILS})
    endif()
    set_property(GLOBAL PROPERTY rupkg_package_${package}_PACKAGE ${RUPKG_REQUIRED_PACKAGES})
        
    if (NOT RUPKG_SUPPORT_PLATFORMS)
        set(RUPKG_SUPPORT_PLATFORMS ${RUPKG_FULLSUPPORT_PLATFORMS})
    endif()
    if (RUPKG_NOT_SUPPORT_PLATFORMS)
        list(REMOVE_ITEM RUPKG_SUPPORT_PLATFORMS ${RUPKG_NOT_SUPPORT_PLATFORMS})
        set_property(GLOBAL PROPERTY rupkg_package_${package}_NOT_SUPPORT_PLATFORMS ${RUPKG_NOT_SUPPORT_PLATFORMS})
    endif()
    set_property(GLOBAL PROPERTY rupkg_package_${package}_SUPPORT_PLATFORMS ${RUPKG_SUPPORT_PLATFORMS})
endfunction()

function(rupkg_run)
    file(GLOB avaliable_packages CONFIGURE_DEPENDS
        RELATIVE ${RUPKG_SOURCE_DIR}/third_party
        ${RUPKG_SOURCE_DIR}/third_party/*)
    set_property(GLOBAL PROPERTY RUPKG_AVALIABLE_PACKAGES ${avaliable_packages})
    set(invalid_packages )
    foreach(package ${avaliable_packages})
        if (EXISTS "${RUPKG_SOURCE_DIR}/third_party/${package}/CMakeLists.txt" AND EXISTS "${RUPKG_SOURCE_DIR}/third_party/${package}/RupkgInfo.cmake")
            rupkg_load_package(${package} "${RUPKG_SOURCE_DIR}/third_party/${package}")
        else()
            list(APPEND invalid_packages ${package})
        endif()
    endforeach()

    set(packages_dir ${RUPKG_SOURCE_DIR}/packages)
    file(GLOB dirs RELATIVE ${packages_dir} CONFIGURE_DEPENDS "${packages_dir}/*")
    set(avaliable_packages )
    foreach(dir ${dirs})
        if (EXISTS "${packages_dir}/${dir}/CMakeLists.txt" AND EXISTS "${packages_dir}/${dir}/RupkgInfo.cmake")
            rupkg_load_package(${dir} ${packages_dir}/${dir})
            list(APPEND avaliable_packages ${dir})
        endif()
    endforeach()
    foreach(dir ${avaliable_packages})
        get_property(required_packages GLOBAL PROPERTY rupkg_package_${dir}_PACKAGE)
        set(required_third_party ${required_packages})
        list(REMOVE_ITEM required_third_party ${avaliable_packages})
        list(REMOVE_ITEM required_packages ${required_third_party})
        set(${dir}_required_packages ${required_packages})
        set_property(GLOBAL PROPERTY rupkg_package_${dir}_PACKAGE ${required_third_party})
    endforeach()
    set(ordered_packages)
    while(avaliable_packages)
        set(removed off)
        set(_avaliable_packages ${avaliable_packages})
        foreach(dir ${_avaliable_packages})
            list(LENGTH ${dir}_required_packages dir_dep_count)
            if ("${dir_dep_count}" STREQUAL "0")
                list(APPEND ordered_packages ${dir})
                list(REMOVE_ITEM avaliable_packages ${dir})
                set(removed on)
            endif()
        endforeach()
        foreach(dir ${_avaliable_packages})
            list(REMOVE_ITEM ${dir}_required_packages ${ordered_packages})
        endforeach()
        if (NOT ${removed})
            message(FATAL_ERROR "Recycling require")
        endif()
    endwhile()
    foreach(dir ${ordered_packages})
        set_property(GLOBAL APPEND PROPERTY RUPKG_LOAD_PACKAGES ${dir})
        get_property(support_platforms GLOBAL PROPERTY rupkg_package_${dir}_SUPPORT_PLATFORMS)
        get_property(not_support_platforms GLOBAL PROPERTY rupkg_package_${dir}_NOT_SUPPORT_PLATFORMS)

        if (NOT "${RUPKG_PLATFORM}" IN_LIST support_platforms)
            continue()
        endif()

        if (not_support_platforms AND "${RUPKG_PLATFORM}" IN_LIST not_support_platforms)
            continue()
        endif()

        get_property(packages GLOBAL PROPERTY rupkg_package_${dir}_PACKAGE)
        if (packages)
            list(REMOVE_DUPLICATES packages)
            rupkg_internal_require(${packages})
        endif()
        add_subdirectory(${RUPKG_SOURCE_DIR}/packages/${dir} ${RUPKG_BINARY_DIR}/packages/${dir})
    endforeach()

    rupkg_install(FILES ${RUPKG_LIST_DIR}/RupkgInitialize.cmake DESTINATION lib/cmake)
    get_property(utils GLOBAL PROPERTY "_RUPKG_RuXPackage_UTIL")
    if (utils)
        list(REMOVE_DUPLICATES utils)

        set(export_utils )
        foreach(util ${utils})
            get_target_property(target_type ${util} TYPE)
            if (NOT ${target_type} STREQUAL "UTILITY")
                list(APPEND export_utils ${util})
            endif()
        endforeach()
        _export(TARGETS ${export_utils} FILE ${CMAKE_CURRENT_BINARY_DIR}/RuXPackageUtilsTargets.cmake)
    endif()

    get_property(avaliable_packages GLOBAL PROPERTY RUPKG_AVALIABLE_PACKAGES)
    get_property(load_packages GLOBAL PROPERTY RUPKG_LOAD_PACKAGES)
    list(REMOVE_ITEM avaliable_packages ${load_packages})
    if (avaliable_packages)
        foreach(p ${avaliable_packages})
            get_property(support_platforms GLOBAL PROPERTY rupkg_package_${p}_SUPPORT_PLATFORMS)
            get_property(not_support_platforms GLOBAL PROPERTY rupkg_package_${p}_NOT_SUPPORT_PLATFORMS)
            
            if (NOT "${RUPKG_PLATFORM}" IN_LIST support_platforms OR "${RUPKG_PLATFORM}" IN_LIST not_support_platforms)
                list(REMOVE_ITEM avaliable_packages ${p})
            endif()
        endforeach()
        list(REMOVE_ITEM avaliable_packages ${invalid_packages})
        if (avaliable_packages)
            message(STATUS "Package ${avaliable_packages} is not loaded")
        endif()
    endif()
    if (invalid_packages)
        message(STATUS "Not valid packages: ${invalid_packages}")
    endif()
endfunction()

function(rupkg_strip target)
	if (RUPKG_COMPILER_CLANG OR RUPKG_COMPILER_GNU)
		if (NOT RUPKG_PLATFORM_EMSCRIPTEN)
			target_link_options(${target} PRIVATE "$<$<CONFIG:Release>:-Wl,--gc-sections>" "-Wl,--exclude-libs,ALL")
		endif()
	elseif (RUPKG_COMPILER_APPLECLANG)
		target_link_options(${target} PRIVATE "$<$<CONFIG:Release>:-Wl,-dead_strip>")
    elseif (RUPKG_COMPILER_MSVC)
        target_link_options(${target} PRIVATE "$<$<CONFIG:Release>:/OPT:REF>")
	endif()
endfunction()

function(add_executable target)
    _add_executable(${target} ${ARGN})
    set(argn ${ARGN})
    if ("ALIAS" IN_LIST argn OR "IMPORTED" IN_LIST argn)
        return()
    endif()

    file(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/PostBuild_$<CONFIG>_${target}.cmake
        CONTENT "$<GENEX_EVAL:$<TARGET_PROPERTY:${target},POST_BUILD_SCRIPT>>"
        CONDITION $<BOOL:$<TARGET_PROPERTY:${target},POST_BUILD_SCRIPT>>)

    add_custom_command(TARGET ${target} POST_BUILD
        COMMAND
            $<$<BOOL:$<TARGET_PROPERTY:${target},POST_BUILD_SCRIPT>>:${CMAKE_COMMAND}>
            $<$<BOOL:$<TARGET_PROPERTY:${target},POST_BUILD_SCRIPT>>:-P>
            $<$<BOOL:$<TARGET_PROPERTY:${target},POST_BUILD_SCRIPT>>:${CMAKE_CURRENT_BINARY_DIR}/PostBuild_$<CONFIG>_${target}.cmake>)

    if (RUPKG_PLATFORM_WIN32 OR RUPKG_PLATFORM_UWP)
        target_post_build(${target} "
            set(dlls \"$<TARGET_RUNTIME_DLLS:${target}>\")
            if (NOT \"\${dlls}\" STREQUAL \"\")
                foreach(dll \${dlls})
                    execute_process(COMMAND \${CMAKE_COMMAND} -E copy_if_different \${dll} \"$<TARGET_FILE_DIR:${target}>\")
                endforeach()
            endif()
        ")
    endif()
endfunction()

function(target_post_build target script)
    set_property(TARGET ${target} APPEND_STRING PROPERTY
        POST_BUILD_SCRIPT "${script}\n")
endfunction()

function(install)
endfunction()

function(export)
endfunction()

if (RUX_UTILS_FILE)
endif()
